# logic-programming
An exploration of logic programming; leaning toward pragmatism and purity, and yes: you can do both.

So, yeah. I'd like to program in a language that's easy to code (full-featured),
does what I say (declarative), doesn't hurt me (pure).

Is that prolog? ... may...be? Haskell is wonderful, except when I want to do
logic programming, which is all the time, so I'm always building logic 
frameworks on top of Haskell, then using Haskell. I'd like to skip that step,
maybe? (maybe not: building logical frameworks can be fun, too, e.g.: [Reasoned
Schemer](https://mitpress.mit.edu/books/reasoned-schemer-second-edition)).

Prolog has its quirks. I also built an actionable ontology and deployed that
to production... more than once, in Prolog, so I like Prolog.

Sometimes.

Except when I wish to program functionally, or typefully, which is all the time.

So, you see, I have a quandary. If I had Logic Haskell, or, contrapositively,
Functional Prolog, ... both with Pi-types, I'd be ... happy?

I suppose I have to work on my happiness.

So, here I am: working on my happiness.

You may see some prolog here, you may see some haskell here. ... Idris? I have
to settle on a functional/logical/pragmatic language, and until then, I'll 
explore the established languages until I can parse JSON like python does, and
read and write to graph database like, ... well, python does.

Le sigh.
